4장 설계 품질과 트레이드오프

객체지향 설계: 적절한 책임 부여를 통해 낮은 결합도와 높은 응집도 가지는 것
객체의 상태가 아니라 객체의 행동에 초점을 맞추자.

상태를 분할의 중심 축으로 삼기: 자신이 가지고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의
책임을 분할의 중심 축으로 삼기: 다른 객체가 요청할 수 있는 오프레이션을 위해 필요한 상태를 보관

객체의 상태는 구현에 속한다. 구현은 불안정해서 바뀌기 쉽다. 상태를 중심으로 변경하면, 상태변경에 따라서 인터페이스도 변경하게 된다.
인터페이스 변경이 되면 그것을 구현하는 다른 객체들도 모두 변경되어야 한다.

---
데이터 중심 설계의 예시

변경 가능성이 높은 부분: 구현
변경 가능성이 낮은 부분: 인터페이스


객체지향에서 가장 중요한 원리는 캡슐화이다. 구현을 단순한 인터페이스 뒤로 숨긴다.
유지보수성을 위해서, 변경 가능성이 높은 부분을 설계 뒤로 숨기는 방법이다.
어짜피 메세지와 반환값은 같으니깐 구현만 달라지면 되니깐 문제가 없다.

책임 위주로 설계하고,
상세한 구현은 캡슐화를 통해서 뒤로 숨긴다.

Setter 사용을 막아라!!!
setter를 외부에서 사용하면 만약 그 상태가 없어지거나 변경되면, 그 setter를 사용하는 곳에서도 모두 변경이 이뤄져야함.
만약 setter를 사용하지 않고 그 객체 내부에서 캡슐화되어서 처리된다면, 상태에 대한 변경이 이뤄지더라도 인터페이스 변경이 이뤄지지 않는한.
문제가 없다.
캡슐화가 위반되면서 결합도가 높아진다.
그리고 응집도가 낮아서 하나가 추가되거나, 없어지거나 하면 연관된 것에도 다 변경이 가해진다.
그리고 변경과 상관없는 코드들도 영향 범위에 포함된다.

---
생각이 드는 지점.
분명 줄줄이 써내려간 코드가 있는데,
책임을 정리해서 각 책임을 맡을 객체를 만들어서 역할을 분배하는게 좋겠다.


책임주도 설계하면서 변경 가능한 부분은 다 객체에 책임 할당하면서 캡슐화 시켜놓기
반면 데이터 주도 설계를 하면, 너무 이른 시간에 해당 객체의 데이터를 결정시킨다.
그래서 나중에 변경되면, 해당 객체를 사용하는 모든 곳에서 변경이 일어나야한다.

---
# 핵심
책임 자체가 변하면 어쩔 수 없지만, 구현의 상세사항이 변하는 것은 영향범위를 컨트롤할 수 있다.

setter를 외부에서 사용하면 만약 그 상태가 없어지거나 변경되면, 그 setter를 사용하는 곳에서도 모두 변경이 이뤄져야함.
만약 setter를 사용하지 않고 그 객체 내부에서 캡슐화되어서 처리된다면, 상태에 대한 변경이 이뤄지더라도 인터페이스 변경이 이뤄지지 않는한.
문제가 없다.




