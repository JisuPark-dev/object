# 15 디자인 패턴과 프레임워크
디자인패턴: 설계를 재사용하기

프레임워크: 코드 템플릿 재사용

일관성 있는 협력: 디자인패턴, 프레임워크

## 01 디자인 패턴과 설계 재사용
composite, 전략, 템플릿 메서드, 데코레이터 패턴들

실무적으로 유용하게 범용적으로 사용할 수 있을 아이디어(마틴 파울러)

아키텍처 패턴> 분석 패턴 > 디자인 패턴 > 이디엄

이디엄: 특정 언어에만 국한됨. 

분석 패턴: 도메인 내에서의 문제 해결

---
# composite 패턴
여러개의 객체가 각자 나눠서 component, composite, leaf를 담당하는 경우 
```java
// Component
interface FileSystem {
    void showName();
}

// Leaf
class File implements FileSystem {
    private String name;
    public File(String name) { this.name = name; }

    @Override
    public void showName() {
        System.out.println("📄 " + name);
    }
}

// Composite
class Directory implements FileSystem {
    private String name;
    private List<FileSystem> children = new ArrayList<>();

    public Directory(String name) { this.name = name; }

    public void add(FileSystem fs) {
        children.add(fs);
    }

    @Override
    public void showName() {
        System.out.println("📁 " + name);
        for (FileSystem child : children) {
            child.showName(); // 동일한 인터페이스로 호출 가능
        }
    }
}

// 사용 예시
public class Main {
    public static void main(String[] args) {
        Directory root = new Directory("root");
        root.add(new File("a.txt"));
        root.add(new File("b.txt"));

        Directory subDir = new Directory("sub");
        subDir.add(new File("c.txt"));

        root.add(subDir);

        root.showName();
    }
}
```

## 하나의 객체가 component, composite, leaf 를 모두 하는 경우 
```java
class OrganizationUnit {
    private final String name;
    private final List<OrganizationUnit> children = new ArrayList<>();

    public OrganizationUnit(String name) {
        this.name = name;
    }

    public void add(OrganizationUnit child) {
        children.add(child);
    }

    public void remove(OrganizationUnit child) {
        children.remove(child);
    }

    public void printStructure(String prefix) {
        System.out.println(prefix + "🏢 " + name);
        for (OrganizationUnit child : children) {
            child.printStructure(prefix + "    ");
        }
    }

    public boolean isLeaf() {
        return children.isEmpty();
    }
}

public class Main {
    public static void main(String[] args) {
        OrganizationUnit ceo = new OrganizationUnit("CEO");
        OrganizationUnit dev = new OrganizationUnit("개발팀");
        OrganizationUnit design = new OrganizationUnit("디자인팀");
        OrganizationUnit backend = new OrganizationUnit("백엔드파트");
        OrganizationUnit frontend = new OrganizationUnit("프론트엔드파트");

        ceo.add(dev);
        ceo.add(design);
        dev.add(backend);
        dev.add(frontend);

        ceo.printStructure("");
    }
}
```
| 역할          | 설명                                 |
| ----------- | ---------------------------------- |
| `Component` | 공통 인터페이스 (ex. `FileSystem`)        |
| `Leaf`      | 실제 작업 수행 (ex. `File`)              |
| `Composite` | 여러 Component를 포함 (ex. `Directory`) |

# 전략 패턴
객체 합성을 이용해서 알고리즘 변경을 캡슐화하는 것 -> 추상화에 의존함 

# 템플릿 메서드 패턴
알고리즘을 캡슐화하기 위해서 합성 관계가 아닌 상속 관계를 사용하는 것 

런타임에 바꿀 수는 없지만, 변경이 적다면 상대적으로 전략패턴보다 복잡도를 낮출 수 있다.

# 데코레이터 패턴
```java
// 1️⃣ Component
interface Coffee {
    String getDescription();
    int cost();
}

// 2️⃣ ConcreteComponent
class BasicCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "기본 커피";
    }

    @Override
    public int cost() {
        return 3000;
    }
}

// 3️⃣ Decorator
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;

    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }

    @Override
    public String getDescription() {
        return coffee.getDescription();
    }

    @Override
    public int cost() {
        return coffee.cost();
    }
}

// 4️⃣ ConcreteDecorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", 우유 추가";
    }

    @Override
    public int cost() {
        return super.cost() + 500;
    }
}

class WhipDecorator extends CoffeeDecorator {
    public WhipDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", 휘핑크림 추가";
    }

    @Override
    public int cost() {
        return super.cost() + 700;
    }
}

// 5️⃣ 실행 예시
public class Main {
    public static void main(String[] args) {
        Coffee coffee = new BasicCoffee();
        coffee = new MilkDecorator(coffee);
        coffee = new WhipDecorator(coffee);

        System.out.println(coffee.getDescription() + " = " + coffee.cost() + "원");
    }
}
```
합성을 기본으로 해서 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴이다. super를 사용해서 이전 행동에 하나씩 덮어씌운다. 

---
패턴 만능주의를 경계해라

# 02 프레임워크와 코드 재사용
컴포넌트 재사용은 도메인 사이의 다양성 때문에 비현실적이다.

설계 재사용과 코드 재사용을 적절히 혼합해보자.

변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리한다?
(이 부분 잘 이해 못함)

## 의존성 역전
상위 모델이 하위 모델에 직접 의존하지 말라
상위 모델과 하위 모델 모두 추상화에 의존해라. 

