# 7장 Io병목 해결
## 네트워크 io와 자원효율
서버 프로그램은 기본적으로 네트워크 프로그램이다. 다양한 구성요소와 네트워크로 데이터를 주고받는다.
클라이언트와는 HTTP통신을 한다.
DB는 TCP 기반으로 통신한다.
k8s ClusterIP 서비스는 L4 레벨에서 동작해서 HTTP 같은 L7 프로토콜을 직접 다루지 않고, TCP 연결만 대상으로 트래픽을 전달한다.

네트워크 통신은 2가지로 된다.
출력 스트림으로 데이터 내보내기
입력 스트림으로 데이터 받기
예시) 서버가 db에 출력 스트림으로 쿼리를 보냄
-> db에서 온 데이터를 입력 스트림으로 받음. 

일반적으로 입출력이 되는 동안 해당 스레드는 블로킹 상태로 대기한다. 
그래서 cpu사용률을 높이기 위해서 스레드를 많이 만들면 되는데 이것도 스레드가 메모리를 잡아먹기 때문에 무한정 많이 만들 수 없다. 

만약 스레드를 많이 만든다고 해도, 하나의 cpu가 컨텍스트 스위칭을 하면서 수많은 스레드의 작업을 처리하면 컨텍스트 스위칭 비용이 많이 든다. 

톰캣은 요청마다 스레드를 할당하는데, 이렇게 하면 스레드가 많아져서 메모리를 많이 잡아먹고 컨텍스트 스위칭으로 cpu 자원도 낭비된다.
그럼에도 불구하고 대다수의 서비스는 사용자가 많지 않기 때문에 괜찮다. 

하지만 이제 점점 서비스가 성장하면 메모리, cpu자원을 절감하기 위해서 2가지 방법이 있다
- 가상스레드, 고 루틴, 코루틴과 같은 경량 스레드 사용
- 논블로킹 또는 비동기 io 사용

실제로 성능 문제가 생길 때 도입을 고려해보는 것이 좋다. 

## 가상 스레드로 자원 효율 높이기
경량 스레드는 os가 관리하는 스레드가 아니라 jvm같은 같은 언어의 런타임이 관리하는 스레드이다. 
언어 런타임이 os스레드로 실행할 경량 스레드를 스캐줄링 한다. 
스케줄러 풀에는 os 스레드와 같은 수의 1:1로 매핑된(마운트된) 플랫폼 스레드(캐리어 스레드라고도 한다)가 있다. 

기본 스레드 크기가 1mb인데, 가상스레드는 2kb수준이다. 

1만개의 가상스레드 + 8개의 플랫폼 스래드 = 28mb정도만 사용한다. (물론 호출 스택의 깊이에 따라서 스래드 크기를 늘렸다가 줄인다)

### 네트워크 io와 가상 스레드
synchronized일 경우 플랫폼 스레드에 블라킹이 걸린다

### 가상스레드와 성능
io작업일 때 효과가 좋음. cpu작업에서는 효과 없음
가상스레드가 플랫폼 스레드보다 적으면 이점을 못얻는다. 

원래는 스래드풀을 만들어서 사용하는데, 가상스레드는 생성비용이 워낙 작아서 미리 스레드풀을 만들어두지는 않고, 그냥 생성해서 사용하고 다 쓰면 소멸시킨다. 

### 가상스레드의 장점
기존 코드를 크게 바꿀 필요가 없다는 것임. 

## 논 블로킹 IO로 성능 높이기
사용자가 폭발적으로 증가하면 언젠가는 가상스레드도 한계가 오긴 한다. 메모리를 잡아먹고 스케줄링에 시간을 쓰기 때문.

### 논블로킹 io 동작 개요
스래드가 입출력 끝날때까지 대기하지 않는다
