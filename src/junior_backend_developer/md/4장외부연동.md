## 4장 외부연동이 문제일 때 살펴봐야 할 것들
마이크로 서비스 되면서 내부, 외부 연동이 많아짐. 

예시) 자체 서비스는 트래픽 감당이 되는데, 외부 서비스가 트래픽 감당이 안되서 문제가 생김. 

연동 서비스가 많아질수록 연동 서비스의 품질 관리도 신경 써야한다. - 다만, 100% 차단하긴 어렵다. 대신 영향도는 줄여보자. 

## 타임아웃
A서비스는 B서비스를 호출하는데 타임아웃 설정없이 B서비스의 응답이 60초로 늘어났다. 

만약 타임아웃 설정을 안해서 스레드가 남지 않은 상황에서, 외부 연동이 필요 없는 호출이 추가로 들어온다면... 골치아파진다.

타임아웃 설정이 되어있으면, 스레드가 모자라는 일이 줄어든다. 

### 타임아웃 종류
외부 연동을 단순화하면 연결, 요청, 응답, 종료 4단계이다

연결 타임아웃 시간을 설정하자.(3~5초)

응답 대기시간도 타임아웃 설정하자.(5~30초)

2중으로 연결한 경우 : 커머스 서비스 <-> PG서버 <-> 카드가

타임아웃을 너무 짧게 잡을 경우 카드사는 pg서버에게 정상 응답해서 pg에서는 결제가 되었는데, 
커머스 서비스는 카드사가 늦게 준다고 생각해서 타임아웃 에러를 냄
이로 인해서 결제는 되었는데 상품 구매는 안되는 상황이 발생할 수 있음.

이런 상황을 고려해서 타임아웃을 길게 잡는 것이 필요할 때도 있음. 

///
소캣 타임아웃: 패킷 호출 간격에 대한 타임아웃 설정임. 
호출 타임아웃: 총 응답 시간에 대한 타임아웃임. 
호출 = 패킷들의 합

http 요청에서의 타임아웃
acquire time out: 커넥션 풀 획득에 필요한 시간, 커넥션 풀이 사용가능한게 없을 때는 문제가 될 수도 있다. 
connection time out: 3 way handshake 하는 시간
write time out: http 요청 메세지를 서버에 전송하는데 걸리는 시간, 커다란 메세지 보낼 때는 고려해야합니다.
read time out: 요청에 대한 응답을 기다리는 시간 -> 이걸 소캣타임아웃과 호출 타임아웃으로 좀 더 세분화 할 수 있다. 

보통은 서버와 클라이언트를 바로 연결하지 않고, 로드벨런스 방화벽 등을 거치게 되어서, 그 사이의 연결 시간을 타임아웃 설정을 해주는게 중요하다.


statement time out은 쿼리 타임아웃 입니다. 


connection time out에 대해서 생각해봄
몇초일까? 보통은 100ms안으로 되는 것이 해피 케이스임. 

RTT가 (syn, syn-ack 까지 )
같은 region내(데이터 센터), 1~5ms
서로다른 리전 :30~50
대륙: 150~200
일반적인 네트워크 환경 30~300ms

1초 이내에 커넥션 타임아웃은 환료된다. 

한번 맺기 전까지는 rtt를 알 수 없음. 그래서 리눅스는 default로 1초로 함. 
initRTO(initial retransimission timeout) 1초로 고정값이 되어 있다. 

재시도의 경우 기본 6회까지 합니다.

## 재시도
간헐적인 늦음 현상이 생길수도 있다. 이럴 때 재시도를 통해서 성공시켜보자.

다만 연동 api를 다시 호출해도 되는 조건인지 확인이 필요하다. 

가령 포인트 차감을 하는 외부 api호출을 할 때, 잘못하면 2번 차감될 수도 있다.(늦더라도 포인트 차감은 실행될 수 있으므로) 

### 재시도 가능한 경우
- 단순 조회 기능
- 연결 타임아웃: 요청 자체가 안간 거라서 괜찮다. 
- 멱등성을 가진 변경 기능

그리고 같은 api라도 실패 원인에 따라서 재시도 요청을 해야한다.
만약 검증 오류 등으로 인해 실패하면 재시도 해도 마찬가지로 실패할 것이다. 

재시도 횟수: 1~2번이 적당함(총 3번하는 것임)
재시도 간격: 지수적으로 대기시간을 늘리면서 해볼 수 있다. 바로 연달아 하지만 말자.  

만약 연동 서비스가 요청 폭풍으로 인해서 늦어진 상황인데 재시도를 계속해서 한다면 그것도 문제가 된다.
그래서 연동 서비스의 상황과 체격을 고려해서 재시도 정책을 세워야 한다.

(exponential 지수적인)
만약 서버가 여러개가 있다면, jitter값을 줘서 조금이라도 다른 시점에 재시도하도록 동시 요청을 분산하는것도 좋다. 

지수적인 타임아웃을 사용하는 이유가 서버 부하를 경감시키기 위해서인데, 
커넥션 타임아웃에도 지수백오프를 쓰는 것은 이유가 뭘까?

저희 쪽에서도 안모이게 분산시키려고 쓰는 것이긴 하다.

## 동시요청 제한
연동 서비스의 처리 한계량을 명확하게 알자. 그 이상은 보내지 말자. 

## 서킷 브레이커
연동 서비스가 맛이 갔을 때, 대체 서비스로 전환하거나 아예 에러 화면을 바로 보여주는 것이 낫다

닫힘, 열림, 반열림 3가지 상태를 가진다. 닫힘이 비활성화된 것임. 실패 건수가 임계치를 넘어서면 열리면서 활성화된다. 

시간 기준 오류 발생 비율: 10초 요청 중 50%
개수 기준 오류 발생 비율: 100개 중 50%

열림 상태를 지정된 상태동안 유지하다가, 반열림 상태로 전환함. 반 열려서 일부 요청에 대해서 다시 시도해봄. 
일부 시간 혹은 갯수 동안 반열림 상태 유지하다가 닫힘 혹은 열림 판단을 한다. 

서킷 브레이커가 열려있는 동안 연동 서비스가 과부하에서 벗어날 수 있기도 하다. 


트레픽이 시간에 따라서 너무 변동하지 않는 이상 countBased가 나음.
## 외부 연동과 DB 연동 문제
외부 연동 실패시 트렌젝션 롤백은 괜춘
만약 읽기 타임아웃 실패시 트렌젝션 롤백은 이후 외부 api성공시를 고려해야함
이를 잡기 위해서 폴링으로 데이터 정합성 확인해야함. 
혹은 읽기 타임아웃 일정 시간 후 성공 확인 api를 호출해서 확인해보기. 혹은 취소 api호출해보기.

만약 외부 연동 성공했는데 내부 DB연결 실패시에는 취소 api호출하고, 재차 데이터 정합성 맞는지 확인해봐야한다. 

### db커넥션 풀
외부 연동시간이 길어져서 db커넥션 풀이 포화되는 것을 막으려면 외부 연동 전후로 db사용을 하고 트렌젝션을 끊는 것도 방법이다.
대신 이 방법을 쓰면 트렌젝션 롤백이 안되기 때문에 실패 처리를 다르게 해줘야한다. = 보상 트랜젝션, 데이터 후보정

## HTTP 커넥션 풀
너무 많이 생성하면 연동 서비스에 부하줄 수 있음
커넥션 풀 재사용시 연결 시간 고려

## 연동 서비스 이중화
해당 서비스가 핵심인지 여부
이중화 비용감담 여부







